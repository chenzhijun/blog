---
title: java性能优化
date: 2018-03-12 21:42:52
tags: java
categories: java
---

# Java性能优化

今日在图书馆看java编程思想，看了一下午，就起身到处走走。没想到走到了《java性能优化》这本书这里，本来不想拿起来的，后来想着为啥不去看看呢。就拿起来读了一些感兴趣的章节。
前面一章主要讲了一些优化的大纲，已经四个测试。我记得有一个微基准测试。实在无奈，回到家，具体的是那几个测试也忘记了。当时额外看得只有几章，都是挑的感兴趣的读的。有一章讲的是jdbc，又想起之前别人为我的一个问题：spring的事务是怎么实现的？我当时有点懵逼，其实仔细一想，java中链接数据库不就是通过jdbc来操作的么？那我回答jdbc怎么控制事务的是不是就可以了？可那会脑袋一片空，神之尴尬。
java性能优化里面也提到了jpa，Java persistence api。谈到对它进行优化的时候，讲了一些点，预处理语句和语句池。比如使用PreparedStatement而不是直接使用Statement。对一些处理也可以进行批处理。jdbc的事务是基于Connection的。事务的隔离模式有，开销从大到小：

```java
    Transaction_Serializable
    Transaction_Repeatable_Read
    Transaction_Read_Commited
    Transaction_read_uncommited
```

其实这些就是数据的事务隔离级别，当然java里面还有一个`NONE`。其实这些事务控制还是根据各数据库提供商来控制的。mysql就提供了上面的四种事务隔离级别。事务也会造成一些问题比如：脏读，幻读，不可重复读。


| 事务隔离级别                    | 脏读    |  不可重复读  |  幻读 |
|  :-----:                      | :-----: | :-----: | :-----: |
| 读未提交（read-uncommitted)     | 是      |   是    | 是 |
| 不可重复读（read-committed）     | 否      |   是    | 是 |
| 可重复读(repeatable-read)       | 否      |   否 | 是 |
| 串行化（serializable）          | 否      |   否 | 否 |


JPA的性能直接受底层jdbc驱动程序的影响，可以尝试减少写入的字段，读取更少的数据或一次读取更多的数据(延时加载)(什么是延时加载？有什么好处？怎么实现？)

事务分为两种：声明式事务管理，编程式事务管理。（spring的事务怎么实现？）

JPA 缓存

缓存分为全局缓存和实体管理器缓存，实体管理器中的缓存通常称为一级缓存L1,全局缓存又称为二级缓存。（spring data jpa中是否也是这样实现？）

实体管理器实例都有自己的缓存，它会在本地缓存事务中取得数据，在本地缓存事务中写入的数据。只有在事务提交时，这些缓存的数据才会发送到数据库。

JPA缓存只在通过逐渐去访问实体的时候才有效。实体管理器通过主键查找数据时，会先从L2缓存中找。

任何时候用流都记得用缓存流。

